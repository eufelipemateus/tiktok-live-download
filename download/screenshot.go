// Command screenshot is a chromedp example demonstrating how to take a
// screenshot of a specific element and of the entire browser viewport.
package download

import (
	"context"
	"encoding/json"
	"fmt"
	"log"
	"os"

	"strings"
	"sync"
	"time"

	"github.com/chromedp/chromedp"
	"github.com/eufelipemateus/go-video/interfaces"
	"github.com/eufelipemateus/go-video/youtube"
	"github.com/steampoweredtaco/gotiktoklive"
	ffmpeg_go "github.com/u2takey/ffmpeg-go"
)

const WIDTH = int64(1024)
const HEIGHT = int64(768)
const USER_AGENT = "Felipe Mateus - Get Image"

var startTime = time.Now()

func GetVideo(url string) {

	// Criar o contexto do chromedp
	ctx, cancel := chromedp.NewContext(context.Background())
	defer cancel()

	timeoutCtx, timeoutCancel := context.WithTimeout(ctx, 2*time.Minute)
	defer timeoutCancel()

	// Número de capturas de tela (número de frames para o vídeo)
	//numFrames := 100                   // por exemplo, capturar 100 frames
	//intervalo := 15 * time.Millisecond // Intervalo de captura (50ms para capturas mais rápidas)

	var sigiState string

	distFolder := "build"

	username := getUsernameFromURL(url)

	filename := fmt.Sprintf("%s-%d-%02d-%02d", username, startTime.Year(), startTime.Month(), startTime.Day())

	outputFileVideo := fmt.Sprintf("%s/%s.mp4", distFolder, filename)
//	outputFileChat := fmt.Sprintf("%s/%s.txt", distFolder, filename)

	// Navegar para a página uma única vez
	err := chromedp.Run(timeoutCtx,
		chromedp.Navigate(url),
		chromedp.WaitVisible("body", chromedp.ByQuery),
		chromedp.InnerHTML(`#SIGI_STATE`, &sigiState, chromedp.ByID),
	)
	if err != nil {
		log.Fatal(err)
	}

//	urlVideoRaw := getURLVideoRaw(sigiState)

	/*
		// Criar a pasta de saída para os frames, caso ainda não exista
		outputDir := "frames"
		err = os.WriteFile(outputDir+"/.keep", []byte(""), 0755) // criar diretório se não existir
		if err != nil {
			log.Fatal(err)
		}

		// Capturar os frames de forma mais rápida
		for i := 0; i < numFrames; i++ {
			var buf []byte

			// Captura de tela do elemento, sem repetir a navegação
			err := chromedp.Run(timeoutCtx,
				chromedp.Screenshot(`[data-e2e="live-room-content"]`, &buf, chromedp.ByQuery), // Captura o screenshot do elemento
			)
			if err != nil {
				log.Println(err)
			}

			// Decodificar a captura de tela (base64)
			img, err := base64.StdEncoding.DecodeString(base64.StdEncoding.EncodeToString(buf))
			if err != nil {
				log.Println(err)
			}

			// Salvar a captura de tela em um arquivo numerado
			// Enviar a imagem para o FFmpeg
			fileName := fmt.Sprintf("%s/frame_%03d.png", outputDir, i+1)
			err = os.WriteFile(fileName, img, 0644)
			if err != nil {
				log.Println(err)
			}

			//fmt.Printf("Captura de tela %d salva como %s\n", i+1, fileName)

			// Pausa mínima entre capturas para evitar sobrecarga (50ms)
			time.Sleep(intervalo)
		}
				fmt.Println("Capturas de tela concluídas. Use o ffmpeg para criar o vídeo.")*/

	startTime = time.Now()
	var wg sync.WaitGroup
	wg.Add(2)

/*	go downloadVideo(urlVideoRaw, outputFileVideo, &wg)
	os.Remove(outputFileChat)

	go getChat(username, outputFileChat, &wg)

	wg.Wait()
*/
	//os.Remove(outputFinalFile)
	// GenerateVideoFinal(outputFileVideo, outputFinalFile, outputFileChat)


	title := fmt.Sprintf("Live @%s - %s", username, startTime.Format("02/01/2006"))
	youtube.UploadVideo(outputFileVideo,  title, "Live TikTok")

}
func getURLVideoRaw(metada string) string {

	var data interfaces.AutoGenerated
	if err := json.Unmarshal([]byte(metada), &data); err != nil {
		log.Fatalf("Erro ao deserializar o JSON: %v", err)
	}

	var parsedData interfaces.Root
	err := json.Unmarshal([]byte(data.LiveRoom.LiveRoomUserInfo.LiveRoom.StreamData.PullData.StreamData), &parsedData)
	if err != nil {
		log.Fatalf("Erro ao converter JSON: %v", err)
	}

	return parsedData.Data.Origin.Main.Flv
}

func downloadVideo(urlVideoRaw string, outputFile string, wg *sync.WaitGroup) {
	defer wg.Done()

	err := ffmpeg_go.Input(urlVideoRaw).
		Output(outputFile, ffmpeg_go.KwArgs{"c": "copy"}).
		OverWriteOutput().
		Run()

	if err != nil {
		log.Printf("Erro ao baixar o vídeo: %v\n", err)
		return
	}

	log.Printf("Download concluído: %s\n", outputFile)
}

func getChat(username string, filePath string, wg *sync.WaitGroup) {
	defer wg.Done()

	file := openFile(filePath)

	tiktok, err := gotiktoklive.NewTikTok()
	if err != nil {
		panic(err)
	}
	// Track a TikTok user by username
	live, err := tiktok.TrackUser(username)
	if err != nil {
		log.Println(err)
	}

	// Receive livestream events through the live.Events channel
	for event := range live.Events {
		switch e := event.(type) {

		/*
			// You can specify what to do for specific events. All events are listed below.
			case gotiktoklive.UserEvent:
				fmt.Printf("%T : %s %s\n", e, e.Event, e.User.Username)

			// List viewer count
			case gotiktoklive.ViewersEvent:
				fmt.Printf("%T : %d\n", e, e.Viewers)

			// Specify the action for all remaining events
			default:
				fmt.Printf("%T : %+v\n", e, e)*/

		case gotiktoklive.ChatEvent:
			_, err = file.WriteString(fmt.Sprintf("%.4f-%s -> %s\n", time.Since(startTime).Seconds(), e.User.Username, strings.Replace(e.Comment, "'", " ", -1)))

			if err != nil {
				log.Fatalf("Failed to append text: %v", err)
			}
		}
	}

	defer file.Close()

}

func getUsernameFromURL(url string) string {
	// Remove o prefixo "https://www.tiktok.com/@" e extrai o nome do usuário
	username := strings.TrimPrefix(url, "https://www.tiktok.com/@")
	// Remove qualquer sufixo que possa existir após o nome de usuário, como "/live"
	username = strings.Split(username, "/")[0]
	return username
}

func openFile(filePath string) *os.File {
	file, err := os.OpenFile(filePath, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)
	if err != nil {
		log.Fatalf("Failed to open file: %v", err)
	}

	return file
}
